# 원소가 3개인 집합의 모든 부분집합의 갯수
# 각가의 원소가 2개의 경우의 수를 가짐- 포함되거나 안되거나.
# 2 * 2 * 2 = 8 = 2^3
# ------------------

# 1을 비트로 표현하면 0001
# 비트를 왼쪽으로 하나 옮기면, 0010 = 2
# 한 번 더 옮기면 0100 = 4
# 한 번 더 옮기면 1000 = 8
# 즉, 1을 N번 왼쪽으로 옮기는 비트연산을 하면, 원소 개수가 N인 집합의 부분집합 개수와 같다!! 오홍 그러네!

# 0000  -> 각각의 비트가 arr의 원소를 포함할지 안할지를 결정하는 역할 0:포함안한다 / 1: 포함한다.
# 0001
# 0010
# 0100
# 0101
# 0110
# 0111
# 1000

# ----------
# 2진수 표기법: 2가 되면 한자리가 증가

# 0~7까지 증가하면서 각 비트를 이용해 부분집합 생성
n = 3
arr = [1,2,3]
# i우리가 원하는 모든 부분집합의 모양을 가지고 있다. 그래서 1를 j만큼 하나씩 밀면서 i의 모양을 확인하는 것이다.
for i in range(1<<n): #2^n번만큼 반복하겠다. = 지금은 8번 반복
    # i의 비트가 1인지 0인지를 판단
    for j in range(n):
    # 각각의 원소가 포함될지 안될지를 비트랑 비교한다.
        if i & (1<<j):  # 1을 j만큼 왼쪽으로 민다.
            # &연산의 결과가 0이 아닌 무언가 >> 해당비트는 포함
            print(arr[j], end = " ")
    print()
    #코드가 짧긴한데 코드가 짧다고 해서 간결한 코드는 아니다.
    # 읽기쉬운 코드가 간결한 코드다.
    #본인에게 익숙하면 써라. 강사님은 참고로 안씀 ㅋㅋ

# i = 001이고 j가 0이면 맨뒤에 있는 3이 부분집합에 포함된다
# 비트의 번호와 인덱스의 번호가 반대임.
# <- 비트 번호(뒤에서부터)
# -> 인덱스 번호(앞에서부터)