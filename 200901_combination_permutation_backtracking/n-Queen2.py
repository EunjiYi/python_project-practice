# 사실 n-Queen1처럼 할 필요가 없었다.
# 왜냐면 8방 다 marking을 하지 않아도된다.
# 어차피 8방 중에 위쪽 3부분은 이미 위의 행에 퀸이 있기 때문에, 그 퀸에 의해 못들어가는 것으로 marking이 되어있다.


# n-Queen2는 n-Queen1처럼 직관적이진 않지만 코드가 매우 간결하다. = 인사이트 얻어가자.
N = 10 # 배열크기
cnt = 0 # 배열을 놓을 경우의 수

#열의 사용가능 여부를 체크하기 위한 배열
col = [0] * N

#대각 사용가능 여부를 체크하기 위한 배열
#상향 대각
dia1 = [0]* (2*N-1)
#하향 대각
dia2 = [0]* (2*N-1)


def n_queen(r):
    global cnt
    if r >= N:
        cnt += 1
        return
    # 각 행에서 어느 칸에 퀸이 놓여질지 검사
    # 그 행에서 퀸이 놓일 자리가 결정되면 다음행으로 진행
    # 만약에 마지막 행까지 퀸을 놓게되면, 모든 행에 퀸을 놓은것
    # N개의 퀸을 놓은 것이기 때문에. 해를 찾은 것이 된다.
    for i in range(N): #어떤 칼럼에 퀸을 놓을지 검사
        if not col[i] and not dia1[r+i] and not dia2[i-r+N-1]: # 표시가 안 된 자리는 퀸을 놓을 수 있다.
            # 만약에 현재 칸에 퀸을 놓을 수 있으면, 퀸을 놓고
            # r,i에 퀸을 놓고, 그 퀸에 의해 영향 받는 칸에 표시(+1)
            # 다음 행으로 진행
            col[i] = 1
            dia1[r+i] = 1
            dia2[i-r+N-1] = 1
            n_queen(r+1)
            # r,i에 놓인 퀸에 의해 표시되었던 칸을 되돌림(-1)
            col[i] = 0
            dia1[r + i] = 0
            dia2[i - r + N - 1] = 0

    # 반복문이 끝나면 더이상 검사할 대상이 없기 때문에 종료
    return

n_queen(0)
print(cnt)

# 이렇게 쉽다니.